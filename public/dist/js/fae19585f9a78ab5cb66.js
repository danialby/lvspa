(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./node_modules/vue-scrollto/vue-scrollto.js":
/*!***************************************************!*\
  !*** ./node_modules/vue-scrollto/vue-scrollto.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n  * vue-scrollto v2.18.1\n  * (c) 2019 Randjelovic Igor\n  * @license MIT\n  */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, (function () { 'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  /**\n   * https://github.com/gre/bezier-easing\n   * BezierEasing - use bezier curve for transition easing function\n   * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n   */\n\n  // These values are established by empiricism with tests (tradeoff: performance VS precision)\n  var NEWTON_ITERATIONS = 4;\n  var NEWTON_MIN_SLOPE = 0.001;\n  var SUBDIVISION_PRECISION = 0.0000001;\n  var SUBDIVISION_MAX_ITERATIONS = 10;\n\n  var kSplineTableSize = 11;\n  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\n  var float32ArraySupported = typeof Float32Array === 'function';\n\n  function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\n  function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\n  function C (aA1)      { return 3.0 * aA1; }\n\n  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n  function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n  // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n  function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\n  function binarySubdivide (aX, aA, aB, mX1, mX2) {\n    var currentX, currentT, i = 0;\n    do {\n      currentT = aA + (aB - aA) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - aX;\n      if (currentX > 0.0) {\n        aB = currentT;\n      } else {\n        aA = currentT;\n      }\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n  }\n\n  function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n   for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n     var currentSlope = getSlope(aGuessT, mX1, mX2);\n     if (currentSlope === 0.0) {\n       return aGuessT;\n     }\n     var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n     aGuessT -= currentX / currentSlope;\n   }\n   return aGuessT;\n  }\n\n  function LinearEasing (x) {\n    return x;\n  }\n\n  var src = function bezier (mX1, mY1, mX2, mY2) {\n    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n      throw new Error('bezier x values must be in [0, 1] range');\n    }\n\n    if (mX1 === mY1 && mX2 === mY2) {\n      return LinearEasing;\n    }\n\n    // Precompute samples table\n    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n\n    function getTForX (aX) {\n      var intervalStart = 0.0;\n      var currentSample = 1;\n      var lastSample = kSplineTableSize - 1;\n\n      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n        intervalStart += kSampleStepSize;\n      }\n      --currentSample;\n\n      // Interpolate to provide an initial guess for t\n      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n      var guessForT = intervalStart + dist * kSampleStepSize;\n\n      var initialSlope = getSlope(guessForT, mX1, mX2);\n      if (initialSlope >= NEWTON_MIN_SLOPE) {\n        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n      } else if (initialSlope === 0.0) {\n        return guessForT;\n      } else {\n        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n      }\n    }\n\n    return function BezierEasing (x) {\n      // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n      if (x === 0) {\n        return 0;\n      }\n      if (x === 1) {\n        return 1;\n      }\n      return calcBezier(getTForX(x), mY1, mY2);\n    };\n  };\n\n  var easings = {\n    ease: [0.25, 0.1, 0.25, 1.0],\n    linear: [0.0, 0.0, 1.0, 1.0],\n    'ease-in': [0.42, 0.0, 1.0, 1.0],\n    'ease-out': [0.0, 0.0, 0.58, 1.0],\n    'ease-in-out': [0.42, 0.0, 0.58, 1.0]\n  };\n\n  // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n  var supportsPassive = false;\n\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        supportsPassive = true;\n      }\n    });\n    window.addEventListener('test', null, opts);\n  } catch (e) {}\n\n  var _ = {\n    $: function $(selector) {\n      if (typeof selector !== 'string') {\n        return selector;\n      }\n\n      return document.querySelector(selector);\n    },\n    on: function on(element, events, handler) {\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        passive: false\n      };\n\n      if (!(events instanceof Array)) {\n        events = [events];\n      }\n\n      for (var i = 0; i < events.length; i++) {\n        element.addEventListener(events[i], handler, supportsPassive ? opts : false);\n      }\n    },\n    off: function off(element, events, handler) {\n      if (!(events instanceof Array)) {\n        events = [events];\n      }\n\n      for (var i = 0; i < events.length; i++) {\n        element.removeEventListener(events[i], handler);\n      }\n    },\n    cumulativeOffset: function cumulativeOffset(element) {\n      var top = 0;\n      var left = 0;\n\n      do {\n        top += element.offsetTop || 0;\n        left += element.offsetLeft || 0;\n        element = element.offsetParent;\n      } while (element);\n\n      return {\n        top: top,\n        left: left\n      };\n    }\n  };\n\n  var abortEvents = ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'];\n  var defaults = {\n    container: 'body',\n    duration: 500,\n    easing: 'ease',\n    offset: 0,\n    force: true,\n    cancelable: true,\n    onStart: false,\n    onDone: false,\n    onCancel: false,\n    x: false,\n    y: true\n  };\n  function setDefaults(options) {\n    defaults = _extends({}, defaults, options);\n  }\n  var scroller = function scroller() {\n    var element; // element to scroll to\n\n    var container; // container to scroll\n\n    var duration; // duration of the scrolling\n\n    var easing; // easing to be used when scrolling\n\n    var offset; // offset to be added (subtracted)\n\n    var force; // force scroll, even if element is visible\n\n    var cancelable; // indicates if user can cancel the scroll or not.\n\n    var onStart; // callback when scrolling is started\n\n    var onDone; // callback when scrolling is done\n\n    var onCancel; // callback when scrolling is canceled / aborted\n\n    var x; // scroll on x axis\n\n    var y; // scroll on y axis\n\n    var initialX; // initial X of container\n\n    var targetX; // target X of container\n\n    var initialY; // initial Y of container\n\n    var targetY; // target Y of container\n\n    var diffX; // difference\n\n    var diffY; // difference\n\n    var abort; // is scrolling aborted\n\n    var abortEv; // event that aborted scrolling\n\n    var abortFn = function abortFn(e) {\n      if (!cancelable) return;\n      abortEv = e;\n      abort = true;\n    };\n\n    var easingFn;\n    var timeStart; // time when scrolling started\n\n    var timeElapsed; // time elapsed since scrolling started\n\n    var progress; // progress\n\n    function scrollTop(container) {\n      var scrollTop = container.scrollTop;\n\n      if (container.tagName.toLowerCase() === 'body') {\n        // in firefox body.scrollTop always returns 0\n        // thus if we are trying to get scrollTop on a body tag\n        // we need to get it from the documentElement\n        scrollTop = scrollTop || document.documentElement.scrollTop;\n      }\n\n      return scrollTop;\n    }\n\n    function scrollLeft(container) {\n      var scrollLeft = container.scrollLeft;\n\n      if (container.tagName.toLowerCase() === 'body') {\n        // in firefox body.scrollLeft always returns 0\n        // thus if we are trying to get scrollLeft on a body tag\n        // we need to get it from the documentElement\n        scrollLeft = scrollLeft || document.documentElement.scrollLeft;\n      }\n\n      return scrollLeft;\n    }\n\n    function step(timestamp) {\n      if (abort) return done();\n      if (!timeStart) timeStart = timestamp;\n      timeElapsed = timestamp - timeStart;\n      progress = Math.min(timeElapsed / duration, 1);\n      progress = easingFn(progress);\n      topLeft(container, initialY + diffY * progress, initialX + diffX * progress);\n      timeElapsed < duration ? window.requestAnimationFrame(step) : done();\n    }\n\n    function done() {\n      if (!abort) topLeft(container, targetY, targetX);\n      timeStart = false;\n\n      _.off(container, abortEvents, abortFn);\n\n      if (abort && onCancel) onCancel(abortEv, element);\n      if (!abort && onDone) onDone(element);\n    }\n\n    function topLeft(element, top, left) {\n      if (y) element.scrollTop = top;\n      if (x) element.scrollLeft = left;\n\n      if (element.tagName.toLowerCase() === 'body') {\n        // in firefox body.scrollTop doesn't scroll the page\n        // thus if we are trying to scrollTop on a body tag\n        // we need to scroll on the documentElement\n        if (y) document.documentElement.scrollTop = top;\n        if (x) document.documentElement.scrollLeft = left;\n      }\n    }\n\n    function scrollTo(target, _duration) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (_typeof(_duration) === 'object') {\n        options = _duration;\n      } else if (typeof _duration === 'number') {\n        options.duration = _duration;\n      }\n\n      element = _.$(target);\n\n      if (!element) {\n        return console.warn('[vue-scrollto warn]: Trying to scroll to an element that is not on the page: ' + target);\n      }\n\n      container = _.$(options.container || defaults.container);\n      duration = options.duration || defaults.duration;\n      easing = options.easing || defaults.easing;\n      offset = options.hasOwnProperty('offset') ? options.offset : defaults.offset;\n      force = options.hasOwnProperty('force') ? options.force !== false : defaults.force;\n      cancelable = options.hasOwnProperty('cancelable') ? options.cancelable !== false : defaults.cancelable;\n      onStart = options.onStart || defaults.onStart;\n      onDone = options.onDone || defaults.onDone;\n      onCancel = options.onCancel || defaults.onCancel;\n      x = options.x === undefined ? defaults.x : options.x;\n      y = options.y === undefined ? defaults.y : options.y;\n\n      var cumulativeOffsetContainer = _.cumulativeOffset(container);\n\n      var cumulativeOffsetElement = _.cumulativeOffset(element);\n\n      if (typeof offset === 'function') {\n        offset = offset(element, container);\n      }\n\n      initialY = scrollTop(container);\n      targetY = cumulativeOffsetElement.top - cumulativeOffsetContainer.top + offset;\n      initialX = scrollLeft(container);\n      targetX = cumulativeOffsetElement.left - cumulativeOffsetContainer.left + offset;\n      abort = false;\n      diffY = targetY - initialY;\n      diffX = targetX - initialX;\n\n      if (!force) {\n        // When the container is the default (body) we need to use the viewport\n        // height, not the entire body height\n        var containerHeight = container.tagName.toLowerCase() === 'body' ? document.documentElement.clientHeight || window.innerHeight : container.offsetHeight;\n        var containerTop = initialY;\n        var containerBottom = containerTop + containerHeight;\n        var elementTop = targetY - offset;\n        var elementBottom = elementTop + element.offsetHeight;\n\n        if (elementTop >= containerTop && elementBottom <= containerBottom) {\n          // make sure to call the onDone callback even if there is no need to\n          // scroll the container. Fixes #111 (ref #118)\n          if (onDone) onDone(element);\n          return;\n        }\n      }\n\n      if (onStart) onStart(element);\n\n      if (!diffY && !diffX) {\n        if (onDone) onDone(element);\n        return;\n      }\n\n      if (typeof easing === 'string') {\n        easing = easings[easing] || easings['ease'];\n      }\n\n      easingFn = src.apply(src, easing);\n\n      _.on(container, abortEvents, abortFn, {\n        passive: true\n      });\n\n      window.requestAnimationFrame(step);\n      return function () {\n        abortEv = null;\n        abort = true;\n      };\n    }\n\n    return scrollTo;\n  };\n\n  var _scroller = scroller();\n\n  var bindings = []; // store binding data\n\n  function deleteBinding(el) {\n    for (var i = 0; i < bindings.length; ++i) {\n      if (bindings[i].el === el) {\n        bindings.splice(i, 1);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function findBinding(el) {\n    for (var i = 0; i < bindings.length; ++i) {\n      if (bindings[i].el === el) {\n        return bindings[i];\n      }\n    }\n  }\n\n  function getBinding(el) {\n    var binding = findBinding(el);\n\n    if (binding) {\n      return binding;\n    }\n\n    bindings.push(binding = {\n      el: el,\n      binding: {}\n    });\n    return binding;\n  }\n\n  function handleClick(e) {\n    var ctx = getBinding(this).binding;\n    if (!ctx.value) return;\n    e.preventDefault();\n\n    if (typeof ctx.value === 'string') {\n      return _scroller(ctx.value);\n    }\n\n    _scroller(ctx.value.el || ctx.value.element, ctx.value);\n  }\n\n  var VueScrollTo = {\n    bind: function bind(el, binding) {\n      getBinding(el).binding = binding;\n\n      _.on(el, 'click', handleClick);\n    },\n    unbind: function unbind(el) {\n      deleteBinding(el);\n\n      _.off(el, 'click', handleClick);\n    },\n    update: function update(el, binding) {\n      getBinding(el).binding = binding;\n    },\n    scrollTo: _scroller,\n    bindings: bindings\n  };\n\n  var install = function install(Vue, options) {\n    if (options) setDefaults(options);\n    Vue.directive('scroll-to', VueScrollTo);\n    Vue.prototype.$scrollTo = VueScrollTo.scrollTo;\n  };\n\n  if (typeof window !== 'undefined' && window.Vue) {\n    window.VueScrollTo = VueScrollTo;\n    window.VueScrollTo.setDefaults = setDefaults;\n    window.Vue.use(install);\n  }\n\n  VueScrollTo.install = install;\n\n  return VueScrollTo;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXNjcm9sbHRvL3Z1ZS1zY3JvbGx0by5qcz9mMTNjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsS0FBNEQ7QUFDOUQsRUFBRSxTQUM2RDtBQUMvRCxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCLG9DQUFvQztBQUM3RCx5QkFBeUIsOEJBQThCO0FBQ3ZELHlCQUF5QixrQkFBa0I7O0FBRTNDO0FBQ0Esc0NBQXNDLDhEQUE4RDs7QUFFcEc7QUFDQSxvQ0FBb0Msc0VBQXNFOztBQUUxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxtRUFBbUU7QUFDL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGtCQUFrQjs7QUFFbEIsaUJBQWlCOztBQUVqQixlQUFlOztBQUVmLGVBQWU7O0FBRWYsY0FBYzs7QUFFZCxtQkFBbUI7O0FBRW5CLGdCQUFnQjs7QUFFaEIsZUFBZTs7QUFFZixpQkFBaUI7O0FBRWpCLFVBQVU7O0FBRVYsVUFBVTs7QUFFVixpQkFBaUI7O0FBRWpCLGdCQUFnQjs7QUFFaEIsaUJBQWlCOztBQUVqQixnQkFBZ0I7O0FBRWhCLGNBQWM7O0FBRWQsY0FBYzs7QUFFZCxjQUFjOztBQUVkLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjs7QUFFbEIsb0JBQW9COztBQUVwQixpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZS1zY3JvbGx0by92dWUtc2Nyb2xsdG8uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgKiB2dWUtc2Nyb2xsdG8gdjIuMTguMVxuICAqIChjKSAyMDE5IFJhbmRqZWxvdmljIElnb3JcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWxbJ3Z1ZS1zY3JvbGx0byddID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3R5cGVvZihvYmopO1xuICB9XG5cbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmdcbiAgICogQmV6aWVyRWFzaW5nIC0gdXNlIGJlemllciBjdXJ2ZSBmb3IgdHJhbnNpdGlvbiBlYXNpbmcgZnVuY3Rpb25cbiAgICogYnkgR2HDq3RhbiBSZW5hdWRlYXUgMjAxNCAtIDIwMTUg4oCTIE1JVCBMaWNlbnNlXG4gICAqL1xuXG4gIC8vIFRoZXNlIHZhbHVlcyBhcmUgZXN0YWJsaXNoZWQgYnkgZW1waXJpY2lzbSB3aXRoIHRlc3RzICh0cmFkZW9mZjogcGVyZm9ybWFuY2UgVlMgcHJlY2lzaW9uKVxuICB2YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0O1xuICB2YXIgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xuICB2YXIgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxO1xuICB2YXIgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMDtcblxuICB2YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xuICB2YXIga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApO1xuXG4gIHZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nO1xuXG4gIGZ1bmN0aW9uIEEgKGFBMSwgYUEyKSB7IHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7IH1cbiAgZnVuY3Rpb24gQiAoYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTsgfVxuICBmdW5jdGlvbiBDIChhQTEpICAgICAgeyByZXR1cm4gMy4wICogYUExOyB9XG5cbiAgLy8gUmV0dXJucyB4KHQpIGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIHkodCkgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cbiAgZnVuY3Rpb24gY2FsY0JlemllciAoYVQsIGFBMSwgYUEyKSB7IHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDsgfVxuXG4gIC8vIFJldHVybnMgZHgvZHQgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgZHkvZHQgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cbiAgZnVuY3Rpb24gZ2V0U2xvcGUgKGFULCBhQTEsIGFBMikgeyByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKTsgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZSAoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcbiAgICB2YXIgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcbiAgICBkbyB7XG4gICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuICAgIHJldHVybiBjdXJyZW50VDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlIChhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7ICsraSkge1xuICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHtcbiAgICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICAgfVxuICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgfVxuICAgcmV0dXJuIGFHdWVzc1Q7XG4gIH1cblxuICBmdW5jdGlvbiBMaW5lYXJFYXNpbmcgKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIHZhciBzcmMgPSBmdW5jdGlvbiBiZXppZXIgKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICAgIGlmICghKDAgPD0gbVgxICYmIG1YMSA8PSAxICYmIDAgPD0gbVgyICYmIG1YMiA8PSAxKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdiZXppZXIgeCB2YWx1ZXMgbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2UnKTtcbiAgICB9XG5cbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgIHJldHVybiBMaW5lYXJFYXNpbmc7XG4gICAgfVxuXG4gICAgLy8gUHJlY29tcHV0ZSBzYW1wbGVzIHRhYmxlXG4gICAgdmFyIHNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRGb3JYIChhWCkge1xuICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgICB2YXIgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgICB2YXIgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuXG4gICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgIH1cbiAgICAgIC0tY3VycmVudFNhbXBsZTtcblxuICAgICAgLy8gSW50ZXJwb2xhdGUgdG8gcHJvdmlkZSBhbiBpbml0aWFsIGd1ZXNzIGZvciB0XG4gICAgICB2YXIgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG5cbiAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgfSBlbHNlIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBCZXppZXJFYXNpbmcgKHgpIHtcbiAgICAgIC8vIEJlY2F1c2UgSmF2YVNjcmlwdCBudW1iZXIgYXJlIGltcHJlY2lzZSwgd2Ugc2hvdWxkIGd1YXJhbnRlZSB0aGUgZXh0cmVtZXMgYXJlIHJpZ2h0LlxuICAgICAgaWYgKHggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoeCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgZWFzaW5ncyA9IHtcbiAgICBlYXNlOiBbMC4yNSwgMC4xLCAwLjI1LCAxLjBdLFxuICAgIGxpbmVhcjogWzAuMCwgMC4wLCAxLjAsIDEuMF0sXG4gICAgJ2Vhc2UtaW4nOiBbMC40MiwgMC4wLCAxLjAsIDEuMF0sXG4gICAgJ2Vhc2Utb3V0JzogWzAuMCwgMC4wLCAwLjU4LCAxLjBdLFxuICAgICdlYXNlLWluLW91dCc6IFswLjQyLCAwLjAsIDAuNTgsIDEuMF1cbiAgfTtcblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9FdmVudExpc3RlbmVyT3B0aW9ucy9ibG9iL2doLXBhZ2VzL2V4cGxhaW5lci5tZCNmZWF0dXJlLWRldGVjdGlvblxuICB2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciBfID0ge1xuICAgICQ6IGZ1bmN0aW9uICQoc2VsZWN0b3IpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIH0sXG4gICAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgdmFyIG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIGlmICghKGV2ZW50cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBldmVudHMgPSBbZXZlbnRzXTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50c1tpXSwgaGFuZGxlciwgc3VwcG9ydHNQYXNzaXZlID8gb3B0cyA6IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIGV2ZW50cywgaGFuZGxlcikge1xuICAgICAgaWYgKCEoZXZlbnRzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIGV2ZW50cyA9IFtldmVudHNdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRzW2ldLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGN1bXVsYXRpdmVPZmZzZXQ6IGZ1bmN0aW9uIGN1bXVsYXRpdmVPZmZzZXQoZWxlbWVudCkge1xuICAgICAgdmFyIHRvcCA9IDA7XG4gICAgICB2YXIgbGVmdCA9IDA7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgdG9wICs9IGVsZW1lbnQub2Zmc2V0VG9wIHx8IDA7XG4gICAgICAgIGxlZnQgKz0gZWxlbWVudC5vZmZzZXRMZWZ0IHx8IDA7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgICAgIH0gd2hpbGUgKGVsZW1lbnQpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdDogbGVmdFxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGFib3J0RXZlbnRzID0gWydtb3VzZWRvd24nLCAnd2hlZWwnLCAnRE9NTW91c2VTY3JvbGwnLCAnbW91c2V3aGVlbCcsICdrZXl1cCcsICd0b3VjaG1vdmUnXTtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGNvbnRhaW5lcjogJ2JvZHknLFxuICAgIGR1cmF0aW9uOiA1MDAsXG4gICAgZWFzaW5nOiAnZWFzZScsXG4gICAgb2Zmc2V0OiAwLFxuICAgIGZvcmNlOiB0cnVlLFxuICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgb25TdGFydDogZmFsc2UsXG4gICAgb25Eb25lOiBmYWxzZSxcbiAgICBvbkNhbmNlbDogZmFsc2UsXG4gICAgeDogZmFsc2UsXG4gICAgeTogdHJ1ZVxuICB9O1xuICBmdW5jdGlvbiBzZXREZWZhdWx0cyhvcHRpb25zKSB7XG4gICAgZGVmYXVsdHMgPSBfZXh0ZW5kcyh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBzY3JvbGxlciA9IGZ1bmN0aW9uIHNjcm9sbGVyKCkge1xuICAgIHZhciBlbGVtZW50OyAvLyBlbGVtZW50IHRvIHNjcm9sbCB0b1xuXG4gICAgdmFyIGNvbnRhaW5lcjsgLy8gY29udGFpbmVyIHRvIHNjcm9sbFxuXG4gICAgdmFyIGR1cmF0aW9uOyAvLyBkdXJhdGlvbiBvZiB0aGUgc2Nyb2xsaW5nXG5cbiAgICB2YXIgZWFzaW5nOyAvLyBlYXNpbmcgdG8gYmUgdXNlZCB3aGVuIHNjcm9sbGluZ1xuXG4gICAgdmFyIG9mZnNldDsgLy8gb2Zmc2V0IHRvIGJlIGFkZGVkIChzdWJ0cmFjdGVkKVxuXG4gICAgdmFyIGZvcmNlOyAvLyBmb3JjZSBzY3JvbGwsIGV2ZW4gaWYgZWxlbWVudCBpcyB2aXNpYmxlXG5cbiAgICB2YXIgY2FuY2VsYWJsZTsgLy8gaW5kaWNhdGVzIGlmIHVzZXIgY2FuIGNhbmNlbCB0aGUgc2Nyb2xsIG9yIG5vdC5cblxuICAgIHZhciBvblN0YXJ0OyAvLyBjYWxsYmFjayB3aGVuIHNjcm9sbGluZyBpcyBzdGFydGVkXG5cbiAgICB2YXIgb25Eb25lOyAvLyBjYWxsYmFjayB3aGVuIHNjcm9sbGluZyBpcyBkb25lXG5cbiAgICB2YXIgb25DYW5jZWw7IC8vIGNhbGxiYWNrIHdoZW4gc2Nyb2xsaW5nIGlzIGNhbmNlbGVkIC8gYWJvcnRlZFxuXG4gICAgdmFyIHg7IC8vIHNjcm9sbCBvbiB4IGF4aXNcblxuICAgIHZhciB5OyAvLyBzY3JvbGwgb24geSBheGlzXG5cbiAgICB2YXIgaW5pdGlhbFg7IC8vIGluaXRpYWwgWCBvZiBjb250YWluZXJcblxuICAgIHZhciB0YXJnZXRYOyAvLyB0YXJnZXQgWCBvZiBjb250YWluZXJcblxuICAgIHZhciBpbml0aWFsWTsgLy8gaW5pdGlhbCBZIG9mIGNvbnRhaW5lclxuXG4gICAgdmFyIHRhcmdldFk7IC8vIHRhcmdldCBZIG9mIGNvbnRhaW5lclxuXG4gICAgdmFyIGRpZmZYOyAvLyBkaWZmZXJlbmNlXG5cbiAgICB2YXIgZGlmZlk7IC8vIGRpZmZlcmVuY2VcblxuICAgIHZhciBhYm9ydDsgLy8gaXMgc2Nyb2xsaW5nIGFib3J0ZWRcblxuICAgIHZhciBhYm9ydEV2OyAvLyBldmVudCB0aGF0IGFib3J0ZWQgc2Nyb2xsaW5nXG5cbiAgICB2YXIgYWJvcnRGbiA9IGZ1bmN0aW9uIGFib3J0Rm4oZSkge1xuICAgICAgaWYgKCFjYW5jZWxhYmxlKSByZXR1cm47XG4gICAgICBhYm9ydEV2ID0gZTtcbiAgICAgIGFib3J0ID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGVhc2luZ0ZuO1xuICAgIHZhciB0aW1lU3RhcnQ7IC8vIHRpbWUgd2hlbiBzY3JvbGxpbmcgc3RhcnRlZFxuXG4gICAgdmFyIHRpbWVFbGFwc2VkOyAvLyB0aW1lIGVsYXBzZWQgc2luY2Ugc2Nyb2xsaW5nIHN0YXJ0ZWRcblxuICAgIHZhciBwcm9ncmVzczsgLy8gcHJvZ3Jlc3NcblxuICAgIGZ1bmN0aW9uIHNjcm9sbFRvcChjb250YWluZXIpIHtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBjb250YWluZXIuc2Nyb2xsVG9wO1xuXG4gICAgICBpZiAoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2JvZHknKSB7XG4gICAgICAgIC8vIGluIGZpcmVmb3ggYm9keS5zY3JvbGxUb3AgYWx3YXlzIHJldHVybnMgMFxuICAgICAgICAvLyB0aHVzIGlmIHdlIGFyZSB0cnlpbmcgdG8gZ2V0IHNjcm9sbFRvcCBvbiBhIGJvZHkgdGFnXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZ2V0IGl0IGZyb20gdGhlIGRvY3VtZW50RWxlbWVudFxuICAgICAgICBzY3JvbGxUb3AgPSBzY3JvbGxUb3AgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjcm9sbFRvcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxMZWZ0KGNvbnRhaW5lcikge1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBjb250YWluZXIuc2Nyb2xsTGVmdDtcblxuICAgICAgaWYgKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdib2R5Jykge1xuICAgICAgICAvLyBpbiBmaXJlZm94IGJvZHkuc2Nyb2xsTGVmdCBhbHdheXMgcmV0dXJucyAwXG4gICAgICAgIC8vIHRodXMgaWYgd2UgYXJlIHRyeWluZyB0byBnZXQgc2Nyb2xsTGVmdCBvbiBhIGJvZHkgdGFnXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZ2V0IGl0IGZyb20gdGhlIGRvY3VtZW50RWxlbWVudFxuICAgICAgICBzY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjcm9sbExlZnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcCh0aW1lc3RhbXApIHtcbiAgICAgIGlmIChhYm9ydCkgcmV0dXJuIGRvbmUoKTtcbiAgICAgIGlmICghdGltZVN0YXJ0KSB0aW1lU3RhcnQgPSB0aW1lc3RhbXA7XG4gICAgICB0aW1lRWxhcHNlZCA9IHRpbWVzdGFtcCAtIHRpbWVTdGFydDtcbiAgICAgIHByb2dyZXNzID0gTWF0aC5taW4odGltZUVsYXBzZWQgLyBkdXJhdGlvbiwgMSk7XG4gICAgICBwcm9ncmVzcyA9IGVhc2luZ0ZuKHByb2dyZXNzKTtcbiAgICAgIHRvcExlZnQoY29udGFpbmVyLCBpbml0aWFsWSArIGRpZmZZICogcHJvZ3Jlc3MsIGluaXRpYWxYICsgZGlmZlggKiBwcm9ncmVzcyk7XG4gICAgICB0aW1lRWxhcHNlZCA8IGR1cmF0aW9uID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKSA6IGRvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb25lKCkge1xuICAgICAgaWYgKCFhYm9ydCkgdG9wTGVmdChjb250YWluZXIsIHRhcmdldFksIHRhcmdldFgpO1xuICAgICAgdGltZVN0YXJ0ID0gZmFsc2U7XG5cbiAgICAgIF8ub2ZmKGNvbnRhaW5lciwgYWJvcnRFdmVudHMsIGFib3J0Rm4pO1xuXG4gICAgICBpZiAoYWJvcnQgJiYgb25DYW5jZWwpIG9uQ2FuY2VsKGFib3J0RXYsIGVsZW1lbnQpO1xuICAgICAgaWYgKCFhYm9ydCAmJiBvbkRvbmUpIG9uRG9uZShlbGVtZW50KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b3BMZWZ0KGVsZW1lbnQsIHRvcCwgbGVmdCkge1xuICAgICAgaWYgKHkpIGVsZW1lbnQuc2Nyb2xsVG9wID0gdG9wO1xuICAgICAgaWYgKHgpIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IGxlZnQ7XG5cbiAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2JvZHknKSB7XG4gICAgICAgIC8vIGluIGZpcmVmb3ggYm9keS5zY3JvbGxUb3AgZG9lc24ndCBzY3JvbGwgdGhlIHBhZ2VcbiAgICAgICAgLy8gdGh1cyBpZiB3ZSBhcmUgdHJ5aW5nIHRvIHNjcm9sbFRvcCBvbiBhIGJvZHkgdGFnXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc2Nyb2xsIG9uIHRoZSBkb2N1bWVudEVsZW1lbnRcbiAgICAgICAgaWYgKHkpIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICAgIGlmICh4KSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsVG8odGFyZ2V0LCBfZHVyYXRpb24pIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgICAgaWYgKF90eXBlb2YoX2R1cmF0aW9uKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IF9kdXJhdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF9kdXJhdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IF9kdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudCA9IF8uJCh0YXJnZXQpO1xuXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybignW3Z1ZS1zY3JvbGx0byB3YXJuXTogVHJ5aW5nIHRvIHNjcm9sbCB0byBhbiBlbGVtZW50IHRoYXQgaXMgbm90IG9uIHRoZSBwYWdlOiAnICsgdGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgY29udGFpbmVyID0gXy4kKG9wdGlvbnMuY29udGFpbmVyIHx8IGRlZmF1bHRzLmNvbnRhaW5lcik7XG4gICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gfHwgZGVmYXVsdHMuZHVyYXRpb247XG4gICAgICBlYXNpbmcgPSBvcHRpb25zLmVhc2luZyB8fCBkZWZhdWx0cy5lYXNpbmc7XG4gICAgICBvZmZzZXQgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdvZmZzZXQnKSA/IG9wdGlvbnMub2Zmc2V0IDogZGVmYXVsdHMub2Zmc2V0O1xuICAgICAgZm9yY2UgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdmb3JjZScpID8gb3B0aW9ucy5mb3JjZSAhPT0gZmFsc2UgOiBkZWZhdWx0cy5mb3JjZTtcbiAgICAgIGNhbmNlbGFibGUgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdjYW5jZWxhYmxlJykgPyBvcHRpb25zLmNhbmNlbGFibGUgIT09IGZhbHNlIDogZGVmYXVsdHMuY2FuY2VsYWJsZTtcbiAgICAgIG9uU3RhcnQgPSBvcHRpb25zLm9uU3RhcnQgfHwgZGVmYXVsdHMub25TdGFydDtcbiAgICAgIG9uRG9uZSA9IG9wdGlvbnMub25Eb25lIHx8IGRlZmF1bHRzLm9uRG9uZTtcbiAgICAgIG9uQ2FuY2VsID0gb3B0aW9ucy5vbkNhbmNlbCB8fCBkZWZhdWx0cy5vbkNhbmNlbDtcbiAgICAgIHggPSBvcHRpb25zLnggPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRzLnggOiBvcHRpb25zLng7XG4gICAgICB5ID0gb3B0aW9ucy55ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0cy55IDogb3B0aW9ucy55O1xuXG4gICAgICB2YXIgY3VtdWxhdGl2ZU9mZnNldENvbnRhaW5lciA9IF8uY3VtdWxhdGl2ZU9mZnNldChjb250YWluZXIpO1xuXG4gICAgICB2YXIgY3VtdWxhdGl2ZU9mZnNldEVsZW1lbnQgPSBfLmN1bXVsYXRpdmVPZmZzZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldChlbGVtZW50LCBjb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsWSA9IHNjcm9sbFRvcChjb250YWluZXIpO1xuICAgICAgdGFyZ2V0WSA9IGN1bXVsYXRpdmVPZmZzZXRFbGVtZW50LnRvcCAtIGN1bXVsYXRpdmVPZmZzZXRDb250YWluZXIudG9wICsgb2Zmc2V0O1xuICAgICAgaW5pdGlhbFggPSBzY3JvbGxMZWZ0KGNvbnRhaW5lcik7XG4gICAgICB0YXJnZXRYID0gY3VtdWxhdGl2ZU9mZnNldEVsZW1lbnQubGVmdCAtIGN1bXVsYXRpdmVPZmZzZXRDb250YWluZXIubGVmdCArIG9mZnNldDtcbiAgICAgIGFib3J0ID0gZmFsc2U7XG4gICAgICBkaWZmWSA9IHRhcmdldFkgLSBpbml0aWFsWTtcbiAgICAgIGRpZmZYID0gdGFyZ2V0WCAtIGluaXRpYWxYO1xuXG4gICAgICBpZiAoIWZvcmNlKSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIGNvbnRhaW5lciBpcyB0aGUgZGVmYXVsdCAoYm9keSkgd2UgbmVlZCB0byB1c2UgdGhlIHZpZXdwb3J0XG4gICAgICAgIC8vIGhlaWdodCwgbm90IHRoZSBlbnRpcmUgYm9keSBoZWlnaHRcbiAgICAgICAgdmFyIGNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdib2R5JyA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgd2luZG93LmlubmVySGVpZ2h0IDogY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgdmFyIGNvbnRhaW5lclRvcCA9IGluaXRpYWxZO1xuICAgICAgICB2YXIgY29udGFpbmVyQm90dG9tID0gY29udGFpbmVyVG9wICsgY29udGFpbmVySGVpZ2h0O1xuICAgICAgICB2YXIgZWxlbWVudFRvcCA9IHRhcmdldFkgLSBvZmZzZXQ7XG4gICAgICAgIHZhciBlbGVtZW50Qm90dG9tID0gZWxlbWVudFRvcCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIGlmIChlbGVtZW50VG9wID49IGNvbnRhaW5lclRvcCAmJiBlbGVtZW50Qm90dG9tIDw9IGNvbnRhaW5lckJvdHRvbSkge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0byBjYWxsIHRoZSBvbkRvbmUgY2FsbGJhY2sgZXZlbiBpZiB0aGVyZSBpcyBubyBuZWVkIHRvXG4gICAgICAgICAgLy8gc2Nyb2xsIHRoZSBjb250YWluZXIuIEZpeGVzICMxMTEgKHJlZiAjMTE4KVxuICAgICAgICAgIGlmIChvbkRvbmUpIG9uRG9uZShlbGVtZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9uU3RhcnQpIG9uU3RhcnQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGlmZlkgJiYgIWRpZmZYKSB7XG4gICAgICAgIGlmIChvbkRvbmUpIG9uRG9uZShlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGVhc2luZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWFzaW5nID0gZWFzaW5nc1tlYXNpbmddIHx8IGVhc2luZ3NbJ2Vhc2UnXTtcbiAgICAgIH1cblxuICAgICAgZWFzaW5nRm4gPSBzcmMuYXBwbHkoc3JjLCBlYXNpbmcpO1xuXG4gICAgICBfLm9uKGNvbnRhaW5lciwgYWJvcnRFdmVudHMsIGFib3J0Rm4sIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBhYm9ydEV2ID0gbnVsbDtcbiAgICAgICAgYWJvcnQgPSB0cnVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2Nyb2xsVG87XG4gIH07XG5cbiAgdmFyIF9zY3JvbGxlciA9IHNjcm9sbGVyKCk7XG5cbiAgdmFyIGJpbmRpbmdzID0gW107IC8vIHN0b3JlIGJpbmRpbmcgZGF0YVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUJpbmRpbmcoZWwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoYmluZGluZ3NbaV0uZWwgPT09IGVsKSB7XG4gICAgICAgIGJpbmRpbmdzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEJpbmRpbmcoZWwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoYmluZGluZ3NbaV0uZWwgPT09IGVsKSB7XG4gICAgICAgIHJldHVybiBiaW5kaW5nc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5kaW5nKGVsKSB7XG4gICAgdmFyIGJpbmRpbmcgPSBmaW5kQmluZGluZyhlbCk7XG5cbiAgICBpZiAoYmluZGluZykge1xuICAgICAgcmV0dXJuIGJpbmRpbmc7XG4gICAgfVxuXG4gICAgYmluZGluZ3MucHVzaChiaW5kaW5nID0ge1xuICAgICAgZWw6IGVsLFxuICAgICAgYmluZGluZzoge31cbiAgICB9KTtcbiAgICByZXR1cm4gYmluZGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGUpIHtcbiAgICB2YXIgY3R4ID0gZ2V0QmluZGluZyh0aGlzKS5iaW5kaW5nO1xuICAgIGlmICghY3R4LnZhbHVlKSByZXR1cm47XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKHR5cGVvZiBjdHgudmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gX3Njcm9sbGVyKGN0eC52YWx1ZSk7XG4gICAgfVxuXG4gICAgX3Njcm9sbGVyKGN0eC52YWx1ZS5lbCB8fCBjdHgudmFsdWUuZWxlbWVudCwgY3R4LnZhbHVlKTtcbiAgfVxuXG4gIHZhciBWdWVTY3JvbGxUbyA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKGVsLCBiaW5kaW5nKSB7XG4gICAgICBnZXRCaW5kaW5nKGVsKS5iaW5kaW5nID0gYmluZGluZztcblxuICAgICAgXy5vbihlbCwgJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xuICAgIH0sXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQoZWwpIHtcbiAgICAgIGRlbGV0ZUJpbmRpbmcoZWwpO1xuXG4gICAgICBfLm9mZihlbCwgJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZWwsIGJpbmRpbmcpIHtcbiAgICAgIGdldEJpbmRpbmcoZWwpLmJpbmRpbmcgPSBiaW5kaW5nO1xuICAgIH0sXG4gICAgc2Nyb2xsVG86IF9zY3JvbGxlcixcbiAgICBiaW5kaW5nczogYmluZGluZ3NcbiAgfTtcblxuICB2YXIgaW5zdGFsbCA9IGZ1bmN0aW9uIGluc3RhbGwoVnVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMpIHNldERlZmF1bHRzKG9wdGlvbnMpO1xuICAgIFZ1ZS5kaXJlY3RpdmUoJ3Njcm9sbC10bycsIFZ1ZVNjcm9sbFRvKTtcbiAgICBWdWUucHJvdG90eXBlLiRzY3JvbGxUbyA9IFZ1ZVNjcm9sbFRvLnNjcm9sbFRvO1xuICB9O1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuVnVlKSB7XG4gICAgd2luZG93LlZ1ZVNjcm9sbFRvID0gVnVlU2Nyb2xsVG87XG4gICAgd2luZG93LlZ1ZVNjcm9sbFRvLnNldERlZmF1bHRzID0gc2V0RGVmYXVsdHM7XG4gICAgd2luZG93LlZ1ZS51c2UoaW5zdGFsbCk7XG4gIH1cblxuICBWdWVTY3JvbGxUby5pbnN0YWxsID0gaW5zdGFsbDtcblxuICByZXR1cm4gVnVlU2Nyb2xsVG87XG5cbn0pKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-scrollto/vue-scrollto.js\n");

/***/ })

}]);